# Model Context Protocol (MCP): A Comprehensive Guide

MCP is a protocol for connecting LLM/agent applications to external tools and context providers through a consistent client↔server interface. Think of it as "USB-C for AI apps"—instead of building one-off connectors per tool/data source, you connect to servers that speak a standard protocol.

---

## The Core Problem MCP Solves

### M×N → M+N

Without a standard, integrating **M** AI apps (chat, RAG, agents, IDE copilots) with **N** external systems (GitHub, Slack, CRMs, DBs, internal APIs) becomes an **M×N** connector problem.

MCP pushes you toward:
- **N servers**: Tool/system owners expose one MCP server per integration boundary
- **M clients**: App/agent owners implement one MCP client per host runtime

Any compliant client can talk to any compliant server, reducing duplicated integration work.

---

## Architecture

### The Three Pieces

| Component | Role | Examples |
|-----------|------|----------|
| **Host** | The app users interact with; runs the model and orchestration | IDE, desktop app, agent runtime |
| **Client** | Host-side component managing connection to one MCP server | Handles lifecycle, errors, request/response |
| **Server** | Exposes capabilities and mediates access to underlying systems | Files, DBs, SaaS APIs |

### What MCP Standardizes

- **Discovery** — Client asks server what it offers (tools/resources/prompts)
- **Invocation** — Client calls a tool with structured arguments, receives structured result
- **Resource access** — Client reads context from server without baking data-source specifics into the host

### Server Capabilities

MCP servers expose three primitives:

1. **Tools** — Actions with structured inputs/outputs (e.g., `run_query`, `send_email`)
2. **Resources** — Raw data for embeddings, RAG, or context injection (files, API responses, screenshots)
3. **Prompts** — Predefined templates executed as dynamic code that inject snippets into model context

Additional capabilities:
- **Roots** — Allow servers to query open projects in client IDE so actions run in correct directory
- **Sampling** — Enables servers to request model completions from clients while clients retain control over security/privacy/cost

---

## Function Calling vs MCP

A common confusion:

| Concept | What It Is |
|---------|-----------|
| **Function/tool calling** | Model API feature: given a tool schema, model can choose to call it |
| **MCP** | Protocol boundary: standardizes how tools are discovered, invoked, and returned |

In practice: the host uses function calling to decide *what to do*, and MCP is the interface used to *do it* safely and consistently.

---

## Message Protocol

MCP uses JSON-RPC 2.0 message shapes:

**Request** (expects response):
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": { "name": "weather", "arguments": { "location": "San Francisco" } }
}
```

**Response** (answers request `id`):
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": { "temperature": "72°F", "condition": "sunny" }
}
```

**Notification** (no `id`, no response expected):
```json
{
  "jsonrpc": "2.0",
  "method": "$/progress",
  "params": { "message": "Processing…", "progress": 0.8 }
}
```

---

## Transports

### stdio (Local)
- Client starts server process locally, communicates over stdin/stdout
- Great for local tools and dev workflows
- VS Code configuration starts/stops servers via `mcp.json`

### Streamable HTTP (Remote)
- Client uses HTTP POST for requests
- Servers may use SSE for streaming back updates
- Better for remote/multi-client deployments
- Remote HTTP servers run independently

---

## Server Design Principles

### Design for LLMs, Not Humans

MCP servers should be designed for **LLMs as the primary client**, not human developers reading API docs.

**Tool surface design:**
- Expose only essential tools—too many options overwhelm models and degrade tool selection
- Tool descriptions should be direct, structured, and example-rich
- Tools rely on natural-language docstrings to tell the model when/how to call them

**Prefer purpose-built tools over generic primitives:**
- Provide tools aligned to real tasks (e.g., "database migrations") rather than generic "Run SQL" tools
- Generic tools require too much implicit context and increase error risk

**Anti-pattern: Autogenerated MCP servers from APIs**
- Exposes too many tools
- Lacks context/examples LLMs need
- Ineffective in practice

### Design Principles

1. **Keep servers small and focused** — One integration boundary per server when possible
2. **Treat tools as API surface** — Stable names, explicit schemas, good errors
3. **Put auth/rate limits/auditing at server boundary** — Not in prompt glue
4. **Prefer idempotent tools** — Design for retries/timeouts
5. **Expose narrow tools** — E.g., "search customers" rather than arbitrary query execution

---

## Minimal Example

### Server (Python, stdio)

```python
from mcp.server.fastmcp import FastMCP

mcp = FastMCP("Physics-Server")

@mcp.tool()
def kinetic_energy(mass_kg: float, velocity_m_s: float) -> float:
    if mass_kg <= 0:
        raise ValueError("mass_kg must be > 0")
    return 0.5 * mass_kg * (velocity_m_s ** 2)

@mcp.tool()
def gravitational_potential_energy(mass_kg: float, height_m: float, g_m_s2: float = 9.81) -> float:
    if mass_kg <= 0:
        raise ValueError("mass_kg must be > 0")
    return mass_kg * g_m_s2 * height_m

if __name__ == "__main__":
    mcp.run(transport="stdio")
```

### Client Flow (Conceptual)

```text
connect(server)
tools = list_tools()
result = call_tool("kinetic_energy", {"mass_kg": 800, "velocity_m_s": 25})
```

---

## Security

### Integration Boundaries

Treat servers as **integration boundaries** where you concentrate:
- Authentication and authorization
- Policy enforcement
- Auditing and logging
- Least-privilege scope

### Enterprise Deployment

- **OAuth 2.1** for user binding in web-exposed servers
- **Streamable HTTP** for scalable interactions and SSO-aligned deployments
- **Authorization server separation** — Can be physically separate from MCP server
- **Dynamic client registration** — Enables bring-your-own servers without pre-existing relationships
- **Enterprise managed authorization profile** — For governed enterprise integration

### Permission Controls

- Separate read-only vs write tools that can be enabled/disabled
- Role-based access constraints
- "Human-in-the-loop" approvals only help if prompts/scopes are clear and enforced consistently

### Security Best Practices

- Logging and auditing
- Secure storage
- Token validation
- Enterprise servers require curation/limited access

---

## What MCP Is NOT

MCP is infrastructure, not intelligence. It does **not** provide:

| Gap | You Must Build |
|-----|----------------|
| Planning/reasoning | Agent brain, task decomposition |
| Workflow execution | State machines, retries, rollback semantics |
| Security policy | TLS, RBAC, audit logs, tenant isolation |
| Cost/rate limits | Budgets, quotas, guardrails |
| Error handling | Classification, fallbacks, user-safe messaging |
| Consent/governance | Scopes, approvals, explainable prompts |
| Observability | Traces, metrics, log conventions |
| Testing | Mocks, contract tests, replay harnesses |

MCP standardizes I/O between agents and systems—you still build the rest of the house.

---

## Common Limitations

- **No workflow semantics** — Won't coordinate multi-step jobs, retries, or compensating actions
- **No built-in guardrails** — Must add budgets, rate limits, allowlists, safe-mode behavior
- **No observability standard** — Need trace IDs, logs, metrics for debugging
- **Cost/latency cliffs** — Naive "list everything then read everything" patterns explode in calls and tokens
- **Model awareness** — Many models won't "know MCP" unless host teaches tool semantics

---

## MCP for Knowledge Graphs

### Neo4j MCP Server Pattern

Neo4j provides multiple MCP servers:
- Cypher execution (read-only and write variants)
- Graph memory
- Aura provisioning
- Integrations with LangChain and LlamaIndex

### How Models Produce Queries

The model generates Cypher by combining:
- Trained knowledge (syntax)
- Session context (schema, prior queries accumulated during chat)

Query results return as JSON into chat context but aren't persisted unless explicitly written.

### Agent Memory as Graph

Memory types:
- **Short-term** — Session context
- **Long-term** — Episodic, procedural, personal, working memory

Memory graph construction:
1. Entity extraction from memory text
2. Entity resolution (deduplication)
3. Relationship extraction

**Temporal relationships** track preference changes using validity ranges—hard to replicate in pure vector stores.

**Retrieval** combines vector search with graph traversal and community detection over co-mentioned entities.

---

## Patterns That Matter

### Per-Tenant Tool Access
Remote MCP servers can centralize tenant routing, credentials, and policy for customer-specific connectors.

### Vendor Neutrality
Keep agent runtime portable while evolving models/providers behind the host.

### Streaming UX
Transports supporting streaming (SSE) help latency-sensitive, tool-heavy interactions feel responsive.

### Small Spec, Big Leverage
MCP is intentionally narrow—wrap it with your own orchestration, governance, and observability layers.

---

## Where MCP Appears in Practice

| Context | Pattern |
|---------|---------|
| **Developer tools** | IDEs and coding assistants use MCP servers to safely expose repo access, shell actions, developer services |
| **Enterprise connectors** | MCP servers front internal APIs/DBs with policy, logging, tenant configuration |
| **Agent platforms** | MCP becomes portable "tool bus" that multiple agent runtimes reuse |

---

## Ecosystem & Tooling

### MCP Inspector
Debugging tool to inspect tools/resources/prompts exposed by servers, analogous to browser devtools.

### Server Management
- Local MCP JSON config lists installed servers and tools for discovery
- Servers installable via stdio (local) or remote URL
- Registry: centralized database of servers with filtering/ranking, designed secure and spam-resistant

### Platform Integration
- Windows: server support, registration, predefined servers
- Azure AI Foundry: platform for building/deploying agents with MCP and human oversight patterns

---

## What May Emerge

Teams often want conventions like:
- Structured error vocabularies (timeout vs auth vs invalid input)
- Tool metadata/versioning fields (read-only, side-effecting, deprecations)
- Explicit consent flags (for consistent approval UX)
- Trace IDs and minimal telemetry fields (debugging and audit)

---

## Testing & Evaluation

- **Evals are crucial** — Ensure LLMs can use tools correctly given non-deterministic behavior
- **Contract tests** — For servers; treat tool surfaces as APIs
- **Replay harnesses** — For clients; record and analyze MCP traffic
- **Treat MCP traffic as analyzable data**

---

## Quick Reference

### When to Use MCP
- Multiple AI apps need same tool/data source
- Want portable agent runtimes across model providers
- Need centralized auth/policy at integration boundary
- Building developer tools or enterprise connectors

### When MCP Isn't Enough
- Need workflow coordination (add orchestration layer)
- Need guardrails (add budget/rate-limit layer)
- Need observability (add tracing/metrics layer)
- Need consent flows (add governance UX)

### Design Checklist
- [ ] Small, focused servers (one integration boundary)
- [ ] Tools designed for LLM consumption (examples, structured descriptions)
- [ ] Auth/audit at server boundary
- [ ] Idempotent tools where possible
- [ ] Contract tests for tool surfaces
- [ ] Clear error contracts

---

## Summary

MCP is **plumbing that makes agents connected, not smart**. It solves the M×N integration problem by standardizing how tools are discovered and invoked. Success with MCP requires:

1. **Server design for LLMs** — Purpose-built tools, not API dumps
2. **Security at boundaries** — Auth, policy, audit in servers
3. **Complementary layers** — Orchestration, guardrails, observability on top
4. **Testing discipline** — Evals, contract tests, replay harnesses

The protocol is intentionally narrow—that's the point. Build the rest of the house around it.
